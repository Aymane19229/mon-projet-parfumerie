name: DevSecOps Pipeline

# Pourquoi : Ce pipeline s'ex√©cute automatiquement √† chaque push ou pull request
# Comment : GitHub Actions d√©clenche ce workflow sur les √©v√©nements d√©finis ci-dessous
on:
  push:
    branches: [ main, SecOps ]
  pull_request:
    branches: [ main ]

# Pourquoi : D√©finir les permissions n√©cessaires pour que le workflow puisse ex√©cuter les actions
# Comment : Ces permissions permettent de lire le code, √©crire les r√©sultats, etc.
permissions:
  contents: read
  security-events: write

jobs:
  # ============================================
  # JOB 1: BUILD ET COMPILATION
  # ============================================
  build:
    name: Build Application
    runs-on: ubuntu-latest
    
    # Pourquoi : Utiliser une matrice permet de tester sur plusieurs versions Java si n√©cessaire
    # Comment : On peut ajouter plusieurs versions dans la liste java-version
    strategy:
      matrix:
        java-version: [17]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # Pourquoi : R√©cup√©rer le code source depuis le repo
        # Comment : Action GitHub officielle qui clone le repo dans le runner
        
      - name: Set up JDK ${{ matrix.java-version }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
        # Pourquoi : Installer Java pour compiler le backend Spring Boot
        # Comment : Utilise une distribution OpenJDK (Temurin) compatible avec Spring Boot
        
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
        # Pourquoi : Acc√©l√©rer les builds en cachant les d√©pendances Maven
        # Comment : Si le pom.xml n'a pas chang√©, r√©utilise les d√©pendances d√©j√† t√©l√©charg√©es
        
      - name: Build Backend
        run: |
          cd backend
          mvn clean compile
        # Pourquoi : Compiler le backend pour v√©rifier qu'il n'y a pas d'erreurs
        # Comment : Maven compile le code Java et v√©rifie la syntaxe
        
      - name: Build Frontend
        run: |
          cd frontend
          npm ci
          npm run build
        # Pourquoi : Compiler le frontend React pour v√©rifier qu'il n'y a pas d'erreurs
        # Comment : npm ci installe les d√©pendances et npm run build compile l'app React

  # ============================================
  # JOB 2: SAST - Static Application Security Testing
  # ============================================
  sast:
    name: SAST - SonarQube Code Analysis
    runs-on: ubuntu-latest
    needs: build
    # Pourquoi : Ex√©cuter SAST seulement apr√®s le build r√©ussi
    # Comment : Le besoin "needs: build" garantit que le build passe avant SAST
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'
          
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
      
      - name: Run SpotBugs (Backend Java SAST)
        run: |
          mkdir -p reports/sast
          cd backend
          mvn clean compile
          mvn com.github.spotbugs:spotbugs-maven-plugin:spotbugs -Dspotbugs.outputFormat=xml -Dspotbugs.outputFile=../reports/sast/spotbugs-report.xml || true
        continue-on-error: true
        # Pourquoi : SpotBugs est une alternative √† SonarQube qui fonctionne sans configuration cloud
        #   Il d√©tecte les bugs et vuln√©rabilit√©s dans le code Java :
        #   - Null pointer exceptions
        #   - Probl√®mes de s√©curit√© (weak cryptography, SQL injection, etc.)
        #   - Bugs logiques
        # Comment : SpotBugs analyse le bytecode compil√© et g√©n√®re un rapport XML
        #   C'est open-source et gratuit, contrairement √† SonarQube qui n√©cessite un compte cloud
        
      # SonarQube d√©sactiv√© - On utilise SpotBugs pour SAST (suffisant pour le projet)
      # - name: Run SonarQube Scanner (Backend Java) - Optional
      #   if: ${{ secrets.SONAR_TOKEN }}
      #   uses: sonarsource/sonarqube-scan-action@master
      #   env:
      #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      #     SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      #     SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      #   with:
      #     projectBaseDir: ./backend
      #   continue-on-error: true
      # Note : SonarQube est optionnel. SpotBugs est suffisant pour d√©tecter les vuln√©rabilit√©s SAST.
      
      - name: Run ESLint (Frontend JavaScript/React)
        run: |
          cd frontend
          npm ci
          npm run lint > eslint-report.json 2>&1 || true
        # Pourquoi : ESLint d√©tecte les probl√®mes dans le code JavaScript/React :
        #   - Erreurs de syntaxe
        #   - Probl√®mes de s√©curit√© (ex: dangerouslySetInnerHTML)
        #   - Mauvaises pratiques
        # Comment : ESLint analyse statiquement le code JS/JSX
        #   Le rapport est sauvegard√© pour √™tre pars√© plus tard
        
      - name: Save SAST reports
        run: |
          mkdir -p reports/sast
          # Sauvegarder les rapports pour l'√©tape de parsing
          if [ -f frontend/eslint-report.json ]; then
            cp frontend/eslint-report.json reports/sast/eslint-report.json
          fi
        # Pourquoi : Centraliser tous les rapports SAST dans un dossier
        # Comment : Cr√©er une structure de dossiers pour organiser les rapports
        
      - name: Upload SAST reports
        uses: actions/upload-artifact@v4
        with:
          name: sast-reports
          path: reports/sast/
        if: always()
        # Pourquoi : Sauvegarder les rapports SAST comme artifacts
        # Comment : Permet de r√©cup√©rer les rapports m√™me si le job √©choue partiellement

  # ============================================
  # JOB 3: SCA - Software Composition Analysis
  # ============================================
  sca:
    name: SCA - Dependency Vulnerability Scan
    runs-on: ubuntu-latest
    needs: build
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'
          
      - name: Prepare SCA reports directory
        run: |
          mkdir -p reports/sca
        # Pourquoi : Cr√©er le dossier AVANT d'ex√©cuter les outils
        # Comment : Les outils ont besoin que le dossier existe pour √©crire les rapports
        
      - name: Run OWASP Dependency-Check (Backend Maven)
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'Backend-Parfumerie'
          path: './backend'
          format: 'JSON'
          args: >
            --enableRetired
            --enableExperimental
            --out reports/sca/
        # Pourquoi : OWASP Dependency-Check analyse les d√©pendances Maven pour :
        #   - D√©tecter les vuln√©rabilit√©s connues (CVE)
        #   - Identifier les d√©pendances obsol√®tes ou non maintenues
        #   - V√©rifier les licences des d√©pendances
        # Comment : Il compare les versions des d√©pendances avec des bases de donn√©es
        #   de vuln√©rabilit√©s (NVD, etc.) et g√©n√®re un rapport JSON
        continue-on-error: true
        
      - name: Rename Dependency-Check report
        run: |
          # Dependency-Check g√©n√®re un fichier avec le nom du projet
          if [ -f reports/sca/dependency-check-report.json ]; then
            mv reports/sca/dependency-check-report.json reports/sca/backend-dependency-check-report.json
          elif [ -f reports/sca/Backend-Parfumerie.json ]; then
            mv reports/sca/Backend-Parfumerie.json reports/sca/backend-dependency-check-report.json
          fi
        continue-on-error: true
        # Pourquoi : Standardiser le nom du fichier pour le parser
        # Comment : Dependency-Check peut g√©n√©rer des noms diff√©rents selon la version
        
      - name: Run npm audit (Frontend npm)
        run: |
          cd frontend
          npm ci
          mkdir -p ../reports/sca
          npm audit --json > ../reports/sca/frontend-npm-audit-report.json 2>&1 || echo '{"vulnerabilities":{}}' > ../reports/sca/frontend-npm-audit-report.json
        continue-on-error: true
        # Pourquoi : npm audit scanne les d√©pendances npm pour :
        #   - Trouver les vuln√©rabilit√©s connues dans les packages
        #   - Identifier les packages obsol√®tes
        # Comment : Utilise la base de donn√©es de s√©curit√© npm
        #   Le format JSON permet de parser les r√©sultats facilement
        #   Si npm audit √©choue, cr√©er un JSON vide pour √©viter les erreurs
        
      - name: Verify SCA reports
        run: |
          echo "üìã V√©rification des rapports SCA..."
          ls -la reports/sca/ || echo "‚ö†Ô∏è  Dossier reports/sca/ vide"
          if [ -f reports/sca/backend-dependency-check-report.json ]; then
            echo "‚úÖ Dependency-Check report trouv√©"
            echo "   Taille: $(wc -c < reports/sca/backend-dependency-check-report.json) bytes"
          else
            echo "‚ö†Ô∏è  Dependency-Check report non trouv√©"
            # Cr√©er un rapport vide pour √©viter les erreurs du parser
            echo '{"dependencies":[]}' > reports/sca/backend-dependency-check-report.json
          fi
          if [ -f reports/sca/frontend-npm-audit-report.json ]; then
            echo "‚úÖ npm audit report trouv√©"
            echo "   Taille: $(wc -c < reports/sca/frontend-npm-audit-report.json) bytes"
          else
            echo "‚ö†Ô∏è  npm audit report non trouv√©"
            # Cr√©er un rapport vide pour √©viter les erreurs du parser
            echo '{"vulnerabilities":{}}' > reports/sca/frontend-npm-audit-report.json
          fi
        continue-on-error: true
        # Pourquoi : V√©rifier que les rapports sont g√©n√©r√©s et cr√©er des rapports vides si n√©cessaire
        # Comment : √âvite les erreurs du parser si les outils √©chouent
        
      - name: Upload SCA reports
        uses: actions/upload-artifact@v4
        with:
          name: sca-reports
          path: reports/sca/
        if: always()
        # Pourquoi : Sauvegarder les rapports SCA comme artifacts
        # Comment : Permet de r√©cup√©rer les rapports pour l'analyse ult√©rieure

  # ============================================
  # JOB 4: DAST - Dynamic Application Security Testing
  # ============================================
  dast:
    name: DAST - OWASP ZAP Security Scan
    runs-on: ubuntu-latest
    needs: build
    # Pourquoi : DAST n√©cessite que l'application soit d√©marr√©e
    # Comment : On va d√©marrer l'application puis la scanner
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'
          
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
        # Pourquoi : Acc√©l√©rer le build en r√©utilisant les d√©pendances Maven
        
      - name: Build Backend Application
        run: |
          cd backend
          mvn clean install -DskipTests
        # Pourquoi : Compiler l'application avant de la d√©marrer
        # Comment : Maven cr√©e le JAR dans target/
        continue-on-error: true
        
      - name: Start Backend Application
        run: |
          cd backend
          # Trouver le JAR g√©n√©r√©
          JAR_FILE=$(find target -name "*.jar" ! -name "*-sources.jar" ! -name "*-javadoc.jar" | head -1)
          if [ -z "$JAR_FILE" ]; then
            echo "‚ùå Aucun JAR trouv√© dans target/"
            exit 1
          fi
          echo "üöÄ D√©marrage de l'application: $JAR_FILE"
          nohup java -jar "$JAR_FILE" > ../app.log 2>&1 &
          echo $! > ../app.pid
          # Attendre que l'application d√©marre (v√©rifier le port 8080)
          for i in {1..60}; do
            if curl -f http://localhost:8080/actuator/health 2>/dev/null || curl -f http://localhost:8080 2>/dev/null; then
              echo "‚úÖ Application d√©marr√©e apr√®s ${i}s"
              break
            fi
            sleep 2
          done
        # Pourquoi : D√©marrer l'application Spring Boot pour la tester dynamiquement
        # Comment : Lancer l'app en arri√®re-plan, sauvegarder le PID, et v√©rifier qu'elle r√©pond
        continue-on-error: true
        
      - name: Run OWASP ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.10.0
        with:
          target: 'http://localhost:8080'
          cmd_options: '-a -J'
        # Pourquoi : OWASP ZAP teste l'application EN EX√âCUTION pour :
        #   - D√©tecter les vuln√©rabilit√©s runtime (XSS, SQL injection, etc.)
        #   - Analyser les r√©ponses HTTP
        #   - Tester les endpoints API
        # Comment : ZAP envoie des requ√™tes HTTP malveillantes et analyse les r√©ponses
        #   -a : Active toutes les r√®gles
        #   -J : G√©n√®re un rapport JSON
        continue-on-error: true
        
      - name: Stop Backend Application
        if: always()
        run: |
          if [ -f app.pid ]; then
            kill $(cat app.pid) 2>/dev/null || true
            rm -f app.pid
          fi
          pkill -f "java.*jar" || true
        # Pourquoi : Arr√™ter l'application apr√®s le scan
        # Comment : Tuer le processus avec le PID sauvegard√©
        
      - name: Save DAST reports
        run: |
          mkdir -p reports/dast
          # ZAP peut g√©n√©rer le rapport avec diff√©rents noms selon la version
          ZAP_FOUND=false
          for zap_file in zap_report.json report_json.json zap-baseline-report.json zap_report.xml; do
            if [ -f "$zap_file" ]; then
              echo "‚úÖ Rapport ZAP trouv√©: $zap_file"
              # Si c'est XML, on le convertit en JSON minimal (ou on le garde tel quel)
              if [[ "$zap_file" == *.xml ]]; then
                echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
                echo "‚ö†Ô∏è  Rapport XML d√©tect√©, cr√©ation d'un JSON minimal"
              else
                cp "$zap_file" reports/dast/zap-report.json
              fi
              ZAP_FOUND=true
              break
            fi
          done
          
          if [ "$ZAP_FOUND" = false ]; then
            # Cr√©er un rapport vide si aucun rapport n'est trouv√©
            echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
            echo "‚ö†Ô∏è  Aucun rapport ZAP trouv√©, cr√©ation d'un rapport vide"
          fi
          
          # V√©rifier que le fichier existe et a du contenu
          if [ -f reports/dast/zap-report.json ]; then
            echo "‚úÖ Rapport DAST sauvegard√©: reports/dast/zap-report.json"
            echo "   Taille: $(wc -c < reports/dast/zap-report.json) bytes"
          fi
        continue-on-error: true
        # Pourquoi : Sauvegarder le rapport ZAP pour l'√©tape de parsing
        # Comment : Chercher le rapport sous diff√©rents noms possibles et cr√©er un rapport vide si n√©cessaire
        
      - name: Upload DAST reports
        uses: actions/upload-artifact@v4
        with:
          name: dast-reports
          path: reports/dast/
        if: always()
        # Pourquoi : Sauvegarder les rapports DAST comme artifacts
        # Comment : Permet de r√©cup√©rer les rapports ZAP pour l'analyse

  # ============================================
  # JOB 5: COLLECTE DES RAPPORTS
  # ============================================
  collect-reports:
    name: Collect Security Reports
    runs-on: ubuntu-latest
    needs: [sast, sca, dast]
    # Pourquoi : Collecter tous les rapports apr√®s l'ex√©cution de tous les scans
    # Comment : Ce job attend que SAST, SCA et DAST soient termin√©s
    
    if: always()
    # Pourquoi : Ex√©cuter m√™me si certains jobs √©chouent (pour r√©cup√©rer les rapports)
    # Comment : always() garantit l'ex√©cution ind√©pendamment du r√©sultat
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download SAST artifacts
        uses: actions/download-artifact@v4
        with:
          name: sast-reports
          path: reports/sast
        continue-on-error: true
        # Pourquoi : R√©cup√©rer les rapports SAST des jobs pr√©c√©dents
        # Comment : Les artifacts permettent de partager des fichiers entre jobs
        
      - name: Download SCA artifacts
        uses: actions/download-artifact@v4
        with:
          name: sca-reports
          path: reports/sca
        continue-on-error: true
        
      - name: Download DAST artifacts
        uses: actions/download-artifact@v4
        with:
          name: dast-reports
          path: reports/dast
        continue-on-error: true
        
      - name: Upload all reports
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: reports/
          retention-days: 30
        # Pourquoi : Centraliser tous les rapports de s√©curit√© pour :
        #   - L'analyse et le parsing ult√©rieur
        #   - L'audit et la conformit√©
        #   - La g√©n√©ration de politiques avec LLM
        # Comment : Les artifacts sont disponibles en t√©l√©chargement depuis GitHub
        #   retention-days garde les rapports 30 jours

