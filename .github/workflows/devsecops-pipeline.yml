name: DevSecOps Pipeline

# Pourquoi : Ce pipeline s'ex√©cute automatiquement √† chaque push ou pull request
# Comment : GitHub Actions d√©clenche ce workflow sur les √©v√©nements d√©finis ci-dessous
on:
  push:
    branches: [ main, SecOps ]
  pull_request:
    branches: [ main ]

# Pourquoi : D√©finir les permissions n√©cessaires pour que le workflow puisse ex√©cuter les actions
# Comment : Ces permissions permettent de lire le code, √©crire les r√©sultats, etc.
permissions:
  contents: read
  security-events: write

jobs:
  # ============================================
  # JOB 1: BUILD ET COMPILATION
  # ============================================
  build:
    name: Build Application
    runs-on: ubuntu-latest
    
    # Pourquoi : Utiliser une matrice permet de tester sur plusieurs versions Java si n√©cessaire
    # Comment : On peut ajouter plusieurs versions dans la liste java-version
    strategy:
      matrix:
        java-version: [17]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # Pourquoi : R√©cup√©rer le code source depuis le repo
        # Comment : Action GitHub officielle qui clone le repo dans le runner
        
      - name: Set up JDK ${{ matrix.java-version }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
        # Pourquoi : Installer Java pour compiler le backend Spring Boot
        # Comment : Utilise une distribution OpenJDK (Temurin) compatible avec Spring Boot
        
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
        # Pourquoi : Acc√©l√©rer les builds en cachant les d√©pendances Maven
        # Comment : Si le pom.xml n'a pas chang√©, r√©utilise les d√©pendances d√©j√† t√©l√©charg√©es
        
      - name: Build Backend
        run: |
          cd backend
          mvn clean compile
        # Pourquoi : Compiler le backend pour v√©rifier qu'il n'y a pas d'erreurs
        # Comment : Maven compile le code Java et v√©rifie la syntaxe
        
      - name: Build Frontend
        run: |
          cd frontend
          npm ci
          npm run build
        # Pourquoi : Compiler le frontend React pour v√©rifier qu'il n'y a pas d'erreurs
        # Comment : npm ci installe les d√©pendances et npm run build compile l'app React

  # ============================================
  # JOB 2: SAST - Static Application Security Testing
  # ============================================
  sast:
    name: SAST - SonarQube Code Analysis
    runs-on: ubuntu-latest
    needs: build
    # Pourquoi : Ex√©cuter SAST seulement apr√®s le build r√©ussi
    # Comment : Le besoin "needs: build" garantit que le build passe avant SAST
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'
          
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
      
      - name: Run SpotBugs (Backend Java SAST)
        run: |
          mkdir -p reports/sast
          cd backend
          mvn clean compile
          mvn com.github.spotbugs:spotbugs-maven-plugin:spotbugs -Dspotbugs.outputFormat=xml -Dspotbugs.outputFile=../reports/sast/spotbugs-report.xml || true
        continue-on-error: true
        # Pourquoi : SpotBugs est une alternative √† SonarQube qui fonctionne sans configuration cloud
        #   Il d√©tecte les bugs et vuln√©rabilit√©s dans le code Java :
        #   - Null pointer exceptions
        #   - Probl√®mes de s√©curit√© (weak cryptography, SQL injection, etc.)
        #   - Bugs logiques
        # Comment : SpotBugs analyse le bytecode compil√© et g√©n√®re un rapport XML
        #   C'est open-source et gratuit, contrairement √† SonarQube qui n√©cessite un compte cloud
        
      # SonarQube d√©sactiv√© - On utilise SpotBugs pour SAST (suffisant pour le projet)
      # - name: Run SonarQube Scanner (Backend Java) - Optional
      #   if: ${{ secrets.SONAR_TOKEN }}
      #   uses: sonarsource/sonarqube-scan-action@master
      #   env:
      #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      #     SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      #     SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      #   with:
      #     projectBaseDir: ./backend
      #   continue-on-error: true
      # Note : SonarQube est optionnel. SpotBugs est suffisant pour d√©tecter les vuln√©rabilit√©s SAST.
      
      - name: Run ESLint (Frontend JavaScript/React)
        run: |
          cd frontend
          npm ci
          # ESLint avec format JSON pour le parsing (compatible avec flat config)
          npx eslint . --format json --report-unused-disable-directives --max-warnings 0 > eslint-report.json 2>&1 || true
        # Pourquoi : ESLint d√©tecte les probl√®mes dans le code JavaScript/React :
        #   - Erreurs de syntaxe
        #   - Probl√®mes de s√©curit√© (ex: dangerouslySetInnerHTML)
        #   - Mauvaises pratiques
        # Comment : ESLint analyse statiquement le code JS/JSX
        #   --format json g√©n√®re un rapport JSON compatible avec le parser
        #   Note : --ext n'est plus n√©cessaire avec eslint.config.js (flat config)
        
      - name: Save SAST reports
        run: |
          mkdir -p reports/sast
          # Sauvegarder les rapports pour l'√©tape de parsing
          if [ -f frontend/eslint-report.json ]; then
            cp frontend/eslint-report.json reports/sast/eslint-report.json
            echo "‚úÖ ESLint report copi√©"
          else
            echo "‚ö†Ô∏è  ESLint report non trouv√© dans frontend/"
          fi
          
          # V√©rifier que SpotBugs a g√©n√©r√© son rapport
          if [ -f reports/sast/spotbugs-report.xml ]; then
            echo "‚úÖ SpotBugs report trouv√©"
          else
            echo "‚ö†Ô∏è  SpotBugs report non trouv√©"
            # Cr√©er un rapport XML vide pour √©viter les erreurs
            echo '<?xml version="1.0" encoding="UTF-8"?><BugCollection></BugCollection>' > reports/sast/spotbugs-report.xml
          fi
          
          echo "üìã Contenu de reports/sast/:"
          ls -lah reports/sast/
        continue-on-error: true
        # Pourquoi : Centraliser tous les rapports SAST dans un dossier
        # Comment : Cr√©er une structure de dossiers pour organiser les rapports
        
      - name: Upload SAST reports
        uses: actions/upload-artifact@v4
        with:
          name: sast-reports
          path: reports/sast/
          if-no-files-found: warn
        if: always()
        # Pourquoi : Sauvegarder les rapports SAST comme artifacts
        # Comment : Permet de r√©cup√©rer les rapports m√™me si le job √©choue partiellement
        # if-no-files-found: warn affiche un avertissement si aucun fichier n'est trouv√©

  # ============================================
  # JOB 3: SCA - Software Composition Analysis
  # ============================================
  sca:
    name: SCA - Dependency Vulnerability Scan
    runs-on: ubuntu-latest
    needs: build
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'
          
      - name: Prepare SCA reports directory
        run: |
          mkdir -p reports/sca
        # Pourquoi : Cr√©er le dossier AVANT d'ex√©cuter les outils
        # Comment : Les outils ont besoin que le dossier existe pour √©crire les rapports
        
      - name: Run OWASP Dependency-Check (Backend Maven)
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'Backend-Parfumerie'
          path: './backend'
          format: 'JSON'
          args: >
            --out .
            --enableRetired
            --enableExperimental
            --failOnCVSS 0
        # Pourquoi : OWASP Dependency-Check analyse les d√©pendances Maven pour :
        #   - D√©tecter les vuln√©rabilit√©s connues (CVE)
        #   - Identifier les d√©pendances obsol√®tes ou non maintenues
        #   - V√©rifier les licences des d√©pendances
        # Comment : Il compare les versions des d√©pendances avec des bases de donn√©es
        #   de vuln√©rabilit√©s (NVD, etc.) et g√©n√®re un rapport JSON
        # Note : --out . g√©n√®re √† la racine, on le d√©place ensuite
        continue-on-error: true
        
      - name: Find and Rename Dependency-Check report
        run: |
          echo "üîç Recherche du rapport Dependency-Check..."
          # Dependency-Check peut g√©n√©rer le fichier dans diff√©rents emplacements
          # Chercher dans reports/sca/ et √† la racine
          DEPCHECK_FOUND=false
          
          # Chercher dans reports/sca/
          for file in reports/sca/dependency-check-report.json reports/sca/Backend-Parfumerie.json reports/sca/*.json; do
            if [ -f "$file" ] && [ "$file" != "reports/sca/frontend-npm-audit-report.json" ]; then
              echo "‚úÖ Rapport trouv√©: $file"
              mv "$file" reports/sca/backend-dependency-check-report.json
              DEPCHECK_FOUND=true
              break
            fi
          done
          
          # Chercher √† la racine (Dependency-Check peut g√©n√©rer l√†)
          if [ "$DEPCHECK_FOUND" = false ]; then
            for file in dependency-check-report.json Backend-Parfumerie.json; do
              if [ -f "$file" ]; then
                echo "‚úÖ Rapport trouv√© √† la racine: $file"
                mv "$file" reports/sca/backend-dependency-check-report.json
                DEPCHECK_FOUND=true
                break
              fi
            done
          fi
          
          # Si toujours pas trouv√©, chercher r√©cursivement
          if [ "$DEPCHECK_FOUND" = false ]; then
            FOUND_FILE=$(find . -name "dependency-check-report.json" -o -name "Backend-Parfumerie.json" 2>/dev/null | grep -v node_modules | head -1)
            if [ -n "$FOUND_FILE" ]; then
              echo "‚úÖ Rapport trouv√©: $FOUND_FILE"
              cp "$FOUND_FILE" reports/sca/backend-dependency-check-report.json
              DEPCHECK_FOUND=true
            fi
          fi
          
          if [ "$DEPCHECK_FOUND" = false ]; then
            echo "‚ö†Ô∏è  Aucun rapport Dependency-Check trouv√©, cr√©ation d'un rapport vide"
            echo '{"dependencies":[]}' > reports/sca/backend-dependency-check-report.json
          fi
        continue-on-error: true
        # Pourquoi : Trouver et standardiser le nom du fichier Dependency-Check
        # Comment : Cherche dans plusieurs emplacements possibles et renomme
        
      - name: Run npm audit (Frontend npm)
        run: |
          cd frontend
          npm ci
          mkdir -p ../reports/sca
          npm audit --json > ../reports/sca/frontend-npm-audit-report.json 2>&1 || echo '{"vulnerabilities":{}}' > ../reports/sca/frontend-npm-audit-report.json
        continue-on-error: true
        # Pourquoi : npm audit scanne les d√©pendances npm pour :
        #   - Trouver les vuln√©rabilit√©s connues dans les packages
        #   - Identifier les packages obsol√®tes
        # Comment : Utilise la base de donn√©es de s√©curit√© npm
        #   Le format JSON permet de parser les r√©sultats facilement
        #   Si npm audit √©choue, cr√©er un JSON vide pour √©viter les erreurs
        
      - name: Verify SCA reports
        run: |
          echo "üìã V√©rification des rapports SCA..."
          echo "üìÅ Contenu de reports/sca/:"
          ls -lah reports/sca/ || echo "‚ö†Ô∏è  Dossier reports/sca/ vide"
          echo ""
          echo "üìÅ Contenu de la racine (fichiers JSON):"
          ls -lah *.json 2>/dev/null || echo "Aucun JSON √† la racine"
          echo ""
          
          # V√©rifier Dependency-Check
          if [ -f reports/sca/backend-dependency-check-report.json ]; then
            SIZE=$(wc -c < reports/sca/backend-dependency-check-report.json)
            echo "‚úÖ Dependency-Check report trouv√©: $SIZE bytes"
            if [ "$SIZE" -lt 100 ]; then
              echo "‚ö†Ô∏è  Rapport tr√®s petit, peut √™tre vide"
            fi
          else
            echo "‚ùå Dependency-Check report NON trouv√© dans reports/sca/"
            echo '{"dependencies":[]}' > reports/sca/backend-dependency-check-report.json
          fi
          
          # V√©rifier npm audit
          if [ -f reports/sca/frontend-npm-audit-report.json ]; then
            SIZE=$(wc -c < reports/sca/frontend-npm-audit-report.json)
            echo "‚úÖ npm audit report trouv√©: $SIZE bytes"
            if [ "$SIZE" -lt 50 ]; then
              echo "‚ö†Ô∏è  Rapport tr√®s petit, peut √™tre vide"
            fi
          else
            echo "‚ùå npm audit report NON trouv√©"
            echo '{"vulnerabilities":{}}' > reports/sca/frontend-npm-audit-report.json
          fi
          
          # V√©rifier que les fichiers existent avant l'upload
          echo ""
          echo "üìä R√©sum√© avant upload:"
          echo "   - backend-dependency-check-report.json: $([ -f reports/sca/backend-dependency-check-report.json ] && echo '‚úÖ' || echo '‚ùå')"
          echo "   - frontend-npm-audit-report.json: $([ -f reports/sca/frontend-npm-audit-report.json ] && echo '‚úÖ' || echo '‚ùå')"
        continue-on-error: true
        # Pourquoi : V√©rifier que les rapports sont g√©n√©r√©s et cr√©er des rapports vides si n√©cessaire
        # Comment : √âvite les erreurs du parser si les outils √©chouent, affiche des infos de debug
        
      - name: List files before upload
        run: |
          echo "üìã Fichiers dans reports/sca/ avant upload:"
          find reports/sca/ -type f -exec ls -lh {} \;
          echo ""
          echo "üìä V√©rification finale:"
          [ -f reports/sca/backend-dependency-check-report.json ] && echo "‚úÖ backend-dependency-check-report.json existe" || echo "‚ùå backend-dependency-check-report.json MANQUANT"
          [ -f reports/sca/frontend-npm-audit-report.json ] && echo "‚úÖ frontend-npm-audit-report.json existe" || echo "‚ùå frontend-npm-audit-report.json MANQUANT"
        continue-on-error: true
        
      - name: Upload SCA reports
        uses: actions/upload-artifact@v4
        with:
          name: sca-reports
          path: reports/sca/
          if-no-files-found: warn
        if: always()
        # Pourquoi : Sauvegarder les rapports SCA comme artifacts
        # Comment : Permet de r√©cup√©rer les rapports pour l'analyse ult√©rieure
        # if-no-files-found: warn affiche un avertissement si aucun fichier n'est trouv√©

  # ============================================
  # JOB 4: DAST - Dynamic Application Security Testing
  # ============================================
  dast:
    name: DAST - OWASP ZAP Security Scan
    runs-on: ubuntu-latest
    needs: build
    # Pourquoi : DAST n√©cessite que l'application soit d√©marr√©e
    # Comment : On va d√©marrer l'application puis la scanner
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: parfumerie
          MYSQL_USER: parfumerie
          MYSQL_PASSWORD: parfumerie
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
    
    # Services disponibles (optionnel - pour services externes si n√©cessaire)
    # services:
    #   postgres:
    #     image: postgres:13
    #     env:
    #       POSTGRES_PASSWORD: postgres
    #     options: >-
    #       --health-cmd pg_isready
    #       --health-interval 10s
    #       --health-timeout 5s
    #       --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'
          
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
        # Pourquoi : Acc√©l√©rer le build en r√©utilisant les d√©pendances Maven
        
      - name: Build Backend Application
        run: |
          cd backend
          mvn clean install -DskipTests
        # Pourquoi : Compiler l'application avant de la d√©marrer
        # Comment : Maven cr√©e le JAR dans target/
        continue-on-error: true
        
      - name: Start Backend Application
        env:
          SPRING_DATASOURCE_URL: jdbc:mysql://localhost:3306/parfumerie
          SPRING_DATASOURCE_USERNAME: parfumerie
          SPRING_DATASOURCE_PASSWORD: parfumerie
          SPRING_DATASOURCE_DRIVER_CLASS_NAME: com.mysql.cj.jdbc.Driver
        run: |
          cd backend
          # Trouver le JAR g√©n√©r√©
          JAR_FILE=$(find target -name "*.jar" ! -name "*-sources.jar" ! -name "*-javadoc.jar" | head -1)
          if [ -z "$JAR_FILE" ]; then
            echo "‚ùå Aucun JAR trouv√© dans target/"
            echo "üìã Contenu de target/:"
            ls -lah target/ || echo "Dossier target/ vide"
            exit 1
          fi
          echo "üöÄ D√©marrage de l'application: $JAR_FILE"
          echo "üìã Configuration MySQL:"
          echo "   URL: $SPRING_DATASOURCE_URL"
          echo "   User: $SPRING_DATASOURCE_USERNAME"
          nohup java -jar "$JAR_FILE" > ../app.log 2>&1 &
          APP_PID=$!
          echo $APP_PID > ../app.pid
          echo "üìù PID de l'application: $APP_PID"
          
          # Attendre que l'application d√©marre (v√©rifier le port 8080)
          echo "‚è≥ Attente du d√©marrage de l'application..."
          APP_READY=false
          # Attendre plus longtemps (jusqu'√† 3 minutes) car l'application peut prendre du temps
          for i in {1..90}; do
            # V√©rifier si le processus est toujours en cours
            if ! kill -0 $APP_PID 2>/dev/null; then
              echo "‚ùå L'application s'est arr√™t√©e (code de sortie: $?)"
              echo "üìã Logs de l'application:"
              tail -50 ../app.log || echo "Aucun log disponible"
              exit 1
            fi
            
            # V√©rifier les logs pour voir si l'application est pr√™te
            if grep -q "Started ParfumsApplication" ../app.log 2>/dev/null; then
              echo "‚úÖ Application d√©marr√©e selon les logs (apr√®s ${i}s)"
              # Attendre encore un peu pour que l'application soit compl√®tement pr√™te
              sleep 5
              APP_READY=true
              break
            fi
            
            # V√©rifier si l'application r√©pond (essayer plusieurs m√©thodes)
            if curl -f http://127.0.0.1:8080/actuator/health 2>/dev/null || \
               curl -f http://127.0.0.1:8080 2>/dev/null || \
               curl -f http://localhost:8080/actuator/health 2>/dev/null || \
               curl -f http://localhost:8080 2>/dev/null || \
               curl -f http://[::1]:8080 2>/dev/null; then
              echo "‚úÖ Application d√©marr√©e et r√©pond apr√®s ${i}s"
              APP_READY=true
              break
            fi
            sleep 2
          done
          
          if [ "$APP_READY" = false ]; then
            echo "‚ö†Ô∏è  L'application ne r√©pond pas apr√®s 120s"
            echo "üìã Logs de l'application:"
            tail -50 ../app.log || echo "Aucun log disponible"
            echo "üìã Processus Java en cours:"
            ps aux | grep java || echo "Aucun processus Java trouv√©"
            # Ne pas √©chouer, continuer quand m√™me (ZAP peut quand m√™me scanner)
          fi
        # Pourquoi : D√©marrer l'application Spring Boot pour la tester dynamiquement
        # Comment : Lancer l'app en arri√®re-plan, sauvegarder le PID, et v√©rifier qu'elle r√©pond
        continue-on-error: true
        
      - name: Check Docker Availability
        run: |
          echo "üê≥ V√©rification de Docker..."
          if command -v docker &> /dev/null; then
            docker --version
            echo "‚úÖ Docker est disponible"
            # V√©rifier que Docker peut √™tre utilis√©
            docker ps || echo "‚ö†Ô∏è  Docker daemon peut ne pas √™tre d√©marr√©"
          else
            echo "‚ùå Docker n'est pas install√©"
            echo "‚ö†Ô∏è  L'action zaproxy/action-baseline n√©cessite Docker"
          fi
        continue-on-error: true
        # Pourquoi : V√©rifier que Docker est disponible pour ZAP
        # Comment : L'action zaproxy/action-baseline utilise Docker en interne
        
      - name: Verify Application is Running
        run: |
          echo "üîç V√©rification que l'application est accessible..."
          # Essayer plusieurs m√©thodes de connexion
          APP_ACCESSIBLE=false
          for url in "http://127.0.0.1:8080" "http://localhost:8080" "http://[::1]:8080"; do
            if curl -f "$url" 2>/dev/null || curl -f "$url/actuator/health" 2>/dev/null; then
              echo "‚úÖ Application accessible sur $url"
              APP_ACCESSIBLE=true
              break
            fi
          done
          
          if [ "$APP_ACCESSIBLE" = false ]; then
            echo "‚ö†Ô∏è  Application non accessible via curl"
            echo "üìã Diagnostic d√©taill√©:"
            echo "   Port 8080:"
            netstat -tuln | grep 8080 || echo "   Port 8080 non utilis√©"
            echo "   Processus Java:"
            ps aux | grep java | grep -v grep || echo "   Aucun processus Java trouv√©"
            echo "   Test direct avec wget (si disponible):"
            wget -q --spider http://localhost:8080 2>&1 || echo "   wget non disponible ou √©chec"
            echo "   Test avec telnet (si disponible):"
            timeout 2 bash -c "</dev/tcp/localhost/8080" 2>&1 || echo "   Connexion TCP √©chou√©e"
            # Cr√©er un rapport vide pour √©viter les erreurs
            mkdir -p reports/dast
            echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
            echo "‚ö†Ô∏è  Rapport vide cr√©√© - l'application n'est pas accessible"
          fi
        continue-on-error: true
        
      - name: Run OWASP ZAP Baseline Scan (Docker Direct)
        run: |
          echo "üîç Ex√©cution du scan ZAP avec Docker direct..."
          mkdir -p reports/dast
          
          # V√©rifier que l'application est accessible (essayer plusieurs m√©thodes)
          echo "üîç V√©rification de l'accessibilit√© de l'application..."
          APP_ACCESSIBLE=false
          for url in "http://127.0.0.1:8080" "http://localhost:8080" "http://[::1]:8080"; do
            if curl -f "$url" 2>/dev/null || curl -f "$url/actuator/health" 2>/dev/null; then
              echo "‚úÖ Application accessible sur $url"
              APP_ACCESSIBLE=true
              break
            fi
          done
          
          if [ "$APP_ACCESSIBLE" = false ]; then
            echo "‚ö†Ô∏è  Application non accessible via curl"
            echo "üìã Diagnostic d√©taill√©:"
            echo "   Port 8080:"
            netstat -tuln | grep 8080 || echo "   Port 8080 non utilis√©"
            echo "   Processus Java:"
            ps aux | grep java | grep -v grep | head -5 || echo "   Aucun processus Java trouv√©"
            echo "   Test TCP direct:"
            timeout 2 bash -c "</dev/tcp/localhost/8080" 2>&1 && echo "   ‚úÖ Port 8080 r√©pond" || echo "   ‚ùå Port 8080 ne r√©pond pas"
            echo ""
            echo "‚ö†Ô∏è  L'application semble d√©marr√©e mais ne r√©pond pas aux requ√™tes HTTP"
            echo "‚ö†Ô∏è  ZAP va quand m√™me essayer de scanner (peut fonctionner)"
            echo "‚ö†Ô∏è  Cr√©ation d'un rapport vide en cas d'√©chec"
            echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
            # Ne pas sortir, continuer quand m√™me - ZAP peut parfois scanner m√™me si curl √©choue
          fi
          
          echo "‚úÖ Application accessible, d√©marrage du scan ZAP..."
          
          # V√©rifier Docker
          if ! command -v docker &> /dev/null; then
            echo "‚ùå Docker n'est pas disponible"
            echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
            exit 0
          fi
          
          echo "üê≥ Docker disponible: $(docker --version)"
          
          # T√©l√©charger l'image ZAP si n√©cessaire
          echo "üì• T√©l√©chargement de l'image ZAP (si n√©cessaire)..."
          # Essayer plusieurs noms d'images possibles
          ZAP_IMAGE=""
          for image in "ghcr.io/zaproxy/zaproxy:stable" "owasp/zap2docker-stable" "owasp/zap2docker-weekly"; do
            echo "üîç Tentative avec: $image"
            if docker pull "$image" 2>&1 | tail -10; then
              ZAP_IMAGE="$image"
              echo "‚úÖ Image ZAP t√©l√©charg√©e: $ZAP_IMAGE"
              break
            else
              echo "‚ö†Ô∏è  √âchec avec $image, essai suivant..."
            fi
          done
          
          if [ -z "$ZAP_IMAGE" ]; then
            echo "‚ùå Impossible de t√©l√©charger l'image ZAP avec aucun des noms test√©s"
            echo "‚ö†Ô∏è  Cr√©ation d'un rapport vide"
            echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
            exit 0
          fi
          
          echo "üöÄ Lancement du scan ZAP..."
          echo "üìã Configuration:"
          echo "   - Target: http://localhost:8080"
          echo "   - Network: host (pour acc√©der √† localhost)"
          echo "   - Rapport: /zap/wrk/zap-report.json"
          
          # Ex√©cuter ZAP avec Docker
          # Utiliser --network host pour acc√©der √† localhost:8080 depuis le conteneur
          # Le rapport sera g√©n√©r√© dans /zap/wrk/ gr√¢ce au volume mont√©
            # Essayer plusieurs URLs (IPv4, localhost, IPv6)
            TARGET_URL="http://localhost:8080"
            if [ "$APP_ACCESSIBLE" = true ]; then
              # Si on a trouv√© une URL qui fonctionne, l'utiliser
              TARGET_URL="http://127.0.0.1:8080"
            fi
            
            echo "üéØ URL cible pour ZAP: $TARGET_URL"
            echo "üê≥ Image ZAP utilis√©e: $ZAP_IMAGE"
            # Ex√©cuter ZAP - le rapport sera dans /zap/wrk/ qui correspond √† $(pwd)
            # Cr√©er un r√©pertoire avec les bonnes permissions pour ZAP
            mkdir -p zap-output
            chmod 777 zap-output
            
            # Ex√©cuter ZAP avec root pour √©viter les probl√®mes de permissions
            docker run --rm \
              --network host \
              -v $(pwd)/zap-output:/zap/wrk/:rw \
              -w /zap/wrk \
              -t "$ZAP_IMAGE" \
              zap-baseline.py \
              -t "$TARGET_URL" \
              -J \
              -r zap-report.json \
              -I 2>&1 | tee zap-scan.log || {
            echo "‚ö†Ô∏è  Scan ZAP termin√© avec des erreurs (code: $?)"
            echo "üìã Derni√®res lignes du log:"
            tail -20 zap-scan.log || echo "Aucun log disponible"
          }
          
          # Chercher et copier le rapport
          echo "üîç Recherche du rapport ZAP..."
          REPORT_FOUND=false
          
          # Attendre un peu pour que le rapport soit √©crit
          sleep 3
          
          # V√©rifier les permissions du r√©pertoire de travail
          echo "üìã Permissions du r√©pertoire de travail:"
          ls -ld . || echo "Impossible de lister"
          echo "üìã Fichiers dans le r√©pertoire courant:"
          ls -lah *.json 2>/dev/null | head -10 || echo "Aucun JSON trouv√©"
          
          # Chercher d'abord dans zap-output (r√©pertoire d√©di√© pour ZAP)
          echo "üìÅ Recherche dans zap-output..."
          
          # ZAP avec -a g√©n√®re plusieurs formats, chercher le JSON
          JSON_FILE=""
          
          # Chercher zap-report.json d'abord
          if [ -f zap-output/zap-report.json ]; then
            JSON_FILE="zap-output/zap-report.json"
          # Sinon chercher -a.json (g√©n√©r√© par l'option -a)
          elif [ -f zap-output/-a.json ]; then
            JSON_FILE="zap-output/-a.json"
          # Sinon chercher n'importe quel fichier .json dans zap-output
          else
            JSON_FILE=$(find zap-output -name "*.json" -type f 2>/dev/null | head -1)
          fi
          
          if [ -n "$JSON_FILE" ] && [ -f "$JSON_FILE" ]; then
            SIZE=$(wc -c < "$JSON_FILE")
            echo "‚úÖ Fichier JSON trouv√©: $JSON_FILE ($SIZE bytes)"
            if [ "$SIZE" -gt 100 ]; then
              mkdir -p reports/dast
              cp "$JSON_FILE" reports/dast/zap-report.json
              echo "‚úÖ Rapport ZAP trouv√© et copi√©: $JSON_FILE -> reports/dast/zap-report.json ($SIZE bytes)"
              REPORT_FOUND=true
            else
              echo "‚ö†Ô∏è  Fichier JSON trop petit ($SIZE bytes), probablement vide"
              echo "üìã Contenu du fichier (premi√®res lignes):"
              head -5 "$JSON_FILE" || echo "Impossible de lire le fichier"
            fi
          else
            echo "‚ö†Ô∏è  Aucun fichier JSON trouv√© dans zap-output/"
            echo "üìã Fichiers dans zap-output/:"
            ls -lah zap-output/ 2>/dev/null || echo "R√©pertoire zap-output/ non trouv√©"
          fi
          
          # Chercher aussi dans le r√©pertoire courant (fallback)
          if [ "$REPORT_FOUND" = false ] && [ -f zap-report.json ]; then
            SIZE=$(wc -c < zap-report.json)
            echo "‚úÖ Fichier zap-report.json trouv√© dans le r√©pertoire courant: $SIZE bytes"
            if [ "$SIZE" -gt 100 ]; then
              mkdir -p reports/dast
              cp zap-report.json reports/dast/zap-report.json
              echo "‚úÖ Rapport ZAP trouv√© et copi√©: zap-report.json ($SIZE bytes)"
              REPORT_FOUND=true
            else
              echo "‚ö†Ô∏è  Fichier zap-report.json trop petit ($SIZE bytes), probablement vide"
            fi
          fi
          
          # Chercher r√©cursivement (mais √©viter reports/dast/)
          if [ "$REPORT_FOUND" = false ]; then
            echo "üìÅ Recherche r√©cursive..."
            FOUND_REPORT=$(find . -name "zap*.json" -o -name "*report*.json" 2>/dev/null | \
              grep -v node_modules | \
              grep -v ".git" | \
              grep -v "eslint" | \
              grep -v "npm" | \
              grep -v "reports/dast" | \
              head -1)
            if [ -n "$FOUND_REPORT" ]; then
              # Normaliser le chemin pour √©viter les probl√®mes
              FOUND_REPORT=$(realpath "$FOUND_REPORT" 2>/dev/null || echo "$FOUND_REPORT")
              DEST_PATH=$(realpath reports/dast/zap-report.json 2>/dev/null || echo "reports/dast/zap-report.json")
              
              # √âviter de copier sur le m√™me fichier
              if [ "$FOUND_REPORT" != "$DEST_PATH" ]; then
                mkdir -p reports/dast
                cp "$FOUND_REPORT" reports/dast/zap-report.json
                SIZE=$(wc -c < reports/dast/zap-report.json)
                echo "‚úÖ Rapport ZAP trouv√© et copi√©: $FOUND_REPORT ($SIZE bytes)"
                REPORT_FOUND=true
              else
                echo "‚úÖ Rapport ZAP d√©j√† pr√©sent: $FOUND_REPORT"
                REPORT_FOUND=true
              fi
            fi
          fi
          
          if [ "$REPORT_FOUND" = false ]; then
            echo "‚ö†Ô∏è  Aucun rapport ZAP trouv√© apr√®s le scan"
            echo "üìã Diagnostic d√©taill√©:"
            echo "   Fichiers JSON dans le r√©pertoire courant:"
            ls -lah *.json 2>/dev/null | head -10 || echo "   Aucun JSON √† la racine"
            echo "   Fichiers JSON trouv√©s r√©cursivement:"
            find . -name "*.json" 2>/dev/null | grep -v node_modules | grep -v ".git" | grep -v "reports/dast" | head -10 || echo "   Aucun fichier JSON trouv√©"
            echo "   Fichiers zap* trouv√©s:"
            find . -name "zap*" 2>/dev/null | head -10 || echo "   Aucun fichier zap* trouv√©"
            echo "   Contenu de zap-output/:"
            ls -lah zap-output/ 2>/dev/null || echo "   R√©pertoire zap-output/ non trouv√©"
            echo "   Contenu du log ZAP (derni√®res lignes):"
            tail -30 zap-scan.log 2>/dev/null | grep -i "report\|json\|error\|permission" || echo "   Aucun log disponible"
            echo ""
            echo "‚ö†Ô∏è  Cr√©ation d'un rapport vide"
            mkdir -p reports/dast
            echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
          fi
          
          # V√©rifier la taille du rapport final
          if [ -f reports/dast/zap-report.json ]; then
            SIZE=$(wc -c < reports/dast/zap-report.json)
            echo "‚úÖ Rapport DAST sauvegard√©: reports/dast/zap-report.json"
            echo "   Taille: $SIZE bytes"
            if [ "$SIZE" -lt 50 ]; then
              echo "‚ö†Ô∏è  Rapport tr√®s petit, peut √™tre vide"
            fi
          fi
        continue-on-error: true
        # Pourquoi : Ex√©cuter ZAP avec Docker directement (plus fiable que l'action GitHub)
        # Comment : Utilise Docker directement pour ex√©cuter ZAP
        # Note : --network host permet d'acc√©der √† localhost:8080 depuis le conteneur
        # Note : L'action GitHub zaproxy/action-baseline √©choue souvent avec Docker, donc on utilise Docker direct uniquement
        
      - name: Stop Backend Application
        if: always()
        run: |
          if [ -f app.pid ]; then
            kill $(cat app.pid) 2>/dev/null || true
            rm -f app.pid
          fi
          pkill -f "java.*jar" || true
        # Pourquoi : Arr√™ter l'application apr√®s le scan
        # Comment : Tuer le processus avec le PID sauvegard√©
        
      - name: Save DAST reports
        run: |
          mkdir -p reports/dast
          echo "üîç Recherche du rapport ZAP..."
          echo "üìÅ Fichiers JSON √† la racine:"
          ls -lah *.json 2>/dev/null | head -10 || echo "Aucun JSON trouv√©"
          echo ""
          echo "üìÅ Fichiers dans reports/dast/:"
          ls -lah reports/dast/ 2>/dev/null || echo "Dossier reports/dast/ vide"
          echo ""
          
          # Si le rapport existe d√©j√† dans reports/dast/ (cr√©√© par le scan ZAP)
          if [ -f reports/dast/zap-report.json ]; then
            SIZE=$(wc -c < reports/dast/zap-report.json)
            echo "‚úÖ Rapport ZAP d√©j√† pr√©sent dans reports/dast/: $SIZE bytes"
            if [ "$SIZE" -lt 50 ]; then
              echo "‚ö†Ô∏è  Rapport tr√®s petit, peut √™tre vide"
              echo "üîç Recherche d'un autre rapport..."
            else
              echo "‚úÖ Rapport valide, pas besoin de chercher ailleurs"
              exit 0
            fi
          fi
          
          # ZAP peut g√©n√©rer le rapport avec diff√©rents noms selon la version
          ZAP_FOUND=false
          
          # Chercher dans le r√©pertoire courant
          for zap_file in zap_report.json report_json.json zap-baseline-report.json zap_report.xml; do
            if [ -f "$zap_file" ]; then
              echo "‚úÖ Rapport ZAP trouv√©: $zap_file"
              SIZE=$(wc -c < "$zap_file")
              echo "   Taille: $SIZE bytes"
              
              # Si c'est XML, on le convertit en JSON minimal
              if [[ "$zap_file" == *.xml ]]; then
                echo "‚ö†Ô∏è  Rapport XML d√©tect√©, cr√©ation d'un JSON minimal"
                echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
              else
                cp "$zap_file" reports/dast/zap-report.json
                echo "‚úÖ Rapport copi√© vers reports/dast/zap-report.json"
              fi
              ZAP_FOUND=true
              break
            fi
          done
          
          # Chercher r√©cursivement si pas trouv√©
          if [ "$ZAP_FOUND" = false ]; then
            echo "üîç Recherche r√©cursive du rapport ZAP..."
            FOUND_FILE=$(find . -name "zap*.json" -o -name "*report*.json" 2>/dev/null | \
              grep -v node_modules | \
              grep -v ".git" | \
              grep -v "eslint" | \
              grep -v "npm" | \
              grep -v "reports/dast" | \
              head -1)
            if [ -n "$FOUND_FILE" ]; then
              # Normaliser les chemins pour √©viter les probl√®mes
              FOUND_ABS=$(realpath "$FOUND_FILE" 2>/dev/null || echo "$FOUND_FILE")
              DEST_ABS=$(realpath reports/dast/zap-report.json 2>/dev/null || echo "$(pwd)/reports/dast/zap-report.json")
              
              # √âviter de copier le fichier sur lui-m√™me
              if [ "$FOUND_ABS" != "$DEST_ABS" ]; then
                cp "$FOUND_FILE" reports/dast/zap-report.json
                SIZE=$(wc -c < reports/dast/zap-report.json)
                echo "‚úÖ Rapport ZAP trouv√© et copi√©: $FOUND_FILE ($SIZE bytes)"
                ZAP_FOUND=true
              else
                echo "‚úÖ Rapport ZAP d√©j√† pr√©sent: $FOUND_FILE"
                ZAP_FOUND=true
              fi
            fi
          fi
          
          if [ "$ZAP_FOUND" = false ]; then
            echo "‚ö†Ô∏è  Aucun rapport ZAP trouv√©, cr√©ation d'un rapport vide"
            echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
          fi
          
          # V√©rifier que le fichier existe et a du contenu
          if [ -f reports/dast/zap-report.json ]; then
            SIZE=$(wc -c < reports/dast/zap-report.json)
            echo "‚úÖ Rapport DAST sauvegard√©: reports/dast/zap-report.json"
            echo "   Taille: $SIZE bytes"
            if [ "$SIZE" -lt 50 ]; then
              echo "‚ö†Ô∏è  Rapport tr√®s petit, peut √™tre vide"
            fi
          else
            echo "‚ùå ERREUR: Le fichier zap-report.json n'existe pas apr√®s sauvegarde!"
            # Cr√©er un rapport vide en dernier recours
            echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
          fi
        continue-on-error: true
        # Pourquoi : Sauvegarder le rapport ZAP pour l'√©tape de parsing
        # Comment : Chercher le rapport sous diff√©rents noms possibles et cr√©er un rapport vide si n√©cessaire
        
      - name: List files before upload
        run: |
          echo "üìã Fichiers dans reports/dast/ avant upload:"
          find reports/dast/ -type f -exec ls -lh {} \;
          echo ""
          echo "üìä V√©rification finale:"
          [ -f reports/dast/zap-report.json ] && echo "‚úÖ zap-report.json existe" || echo "‚ùå zap-report.json MANQUANT"
        continue-on-error: true
        
      - name: Upload DAST reports
        uses: actions/upload-artifact@v4
        with:
          name: dast-reports
          path: reports/dast/
          if-no-files-found: warn
        if: always()
        # Pourquoi : Sauvegarder les rapports DAST comme artifacts
        # Comment : Permet de r√©cup√©rer les rapports ZAP pour l'analyse
        # if-no-files-found: warn affiche un avertissement si aucun fichier n'est trouv√©

  # ============================================
  # JOB 5: COLLECTE DES RAPPORTS
  # ============================================
  collect-reports:
    name: Collect Security Reports
    runs-on: ubuntu-latest
    needs: [sast, sca, dast]
    # Pourquoi : Collecter tous les rapports apr√®s l'ex√©cution de tous les scans
    # Comment : Ce job attend que SAST, SCA et DAST soient termin√©s
    
    if: always()
    # Pourquoi : Ex√©cuter m√™me si certains jobs √©chouent (pour r√©cup√©rer les rapports)
    # Comment : always() garantit l'ex√©cution ind√©pendamment du r√©sultat
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download SAST artifacts
        uses: actions/download-artifact@v4
        with:
          name: sast-reports
          path: reports/sast
        continue-on-error: true
        # Pourquoi : R√©cup√©rer les rapports SAST des jobs pr√©c√©dents
        # Comment : Les artifacts permettent de partager des fichiers entre jobs
        
      - name: Download SCA artifacts
        uses: actions/download-artifact@v4
        with:
          name: sca-reports
          path: reports/sca
        continue-on-error: true
        
      - name: Download DAST artifacts
        uses: actions/download-artifact@v4
        with:
          name: dast-reports
          path: reports/dast
        continue-on-error: true
        
      - name: Upload all reports
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: reports/
          retention-days: 30
        # Pourquoi : Centraliser tous les rapports de s√©curit√© pour :
        #   - L'analyse et le parsing ult√©rieur
        #   - L'audit et la conformit√©
        #   - La g√©n√©ration de politiques avec LLM
        # Comment : Les artifacts sont disponibles en t√©l√©chargement depuis GitHub
        #   retention-days garde les rapports 30 jours

