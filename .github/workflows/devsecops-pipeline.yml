name: DevSecOps Pipeline

# Pourquoi : Ce pipeline s'ex√©cute automatiquement √† chaque push ou pull request
# Comment : GitHub Actions d√©clenche ce workflow sur les √©v√©nements d√©finis ci-dessous
on:
  push:
    branches: [ main, SecOps ]
  pull_request:
    branches: [ main ]

# Pourquoi : D√©finir les permissions n√©cessaires pour que le workflow puisse ex√©cuter les actions
# Comment : Ces permissions permettent de lire le code, √©crire les r√©sultats, etc.
permissions:
  contents: read
  security-events: write

jobs:
  # ============================================
  # JOB 1: BUILD ET COMPILATION
  # ============================================
  build:
    name: Build Application
    runs-on: ubuntu-latest
    
    # Pourquoi : Utiliser une matrice permet de tester sur plusieurs versions Java si n√©cessaire
    # Comment : On peut ajouter plusieurs versions dans la liste java-version
    strategy:
      matrix:
        java-version: [17]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # Pourquoi : R√©cup√©rer le code source depuis le repo
        # Comment : Action GitHub officielle qui clone le repo dans le runner
        
      - name: Set up JDK ${{ matrix.java-version }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
        # Pourquoi : Installer Java pour compiler le backend Spring Boot
        # Comment : Utilise une distribution OpenJDK (Temurin) compatible avec Spring Boot
        
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
        # Pourquoi : Acc√©l√©rer les builds en cachant les d√©pendances Maven
        # Comment : Si le pom.xml n'a pas chang√©, r√©utilise les d√©pendances d√©j√† t√©l√©charg√©es
        
      - name: Build Backend
        run: |
          cd backend
          mvn clean compile
        # Pourquoi : Compiler le backend pour v√©rifier qu'il n'y a pas d'erreurs
        # Comment : Maven compile le code Java et v√©rifie la syntaxe
        
      - name: Build Frontend
        run: |
          cd frontend
          npm ci
          npm run build
        # Pourquoi : Compiler le frontend React pour v√©rifier qu'il n'y a pas d'erreurs
        # Comment : npm ci installe les d√©pendances et npm run build compile l'app React

  # ============================================
  # JOB 2: SAST - Static Application Security Testing
  # ============================================
  sast:
    name: SAST - SonarQube Code Analysis
    runs-on: ubuntu-latest
    needs: build
    # Pourquoi : Ex√©cuter SAST seulement apr√®s le build r√©ussi
    # Comment : Le besoin "needs: build" garantit que le build passe avant SAST
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'
          
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
      
      - name: Run SpotBugs (Backend Java SAST)
        run: |
          mkdir -p reports/sast
          cd backend
          mvn clean compile
          mvn com.github.spotbugs:spotbugs-maven-plugin:spotbugs -Dspotbugs.outputFormat=xml -Dspotbugs.outputFile=../reports/sast/spotbugs-report.xml || true
        continue-on-error: true
        # Pourquoi : SpotBugs est une alternative √† SonarQube qui fonctionne sans configuration cloud
        #   Il d√©tecte les bugs et vuln√©rabilit√©s dans le code Java :
        #   - Null pointer exceptions
        #   - Probl√®mes de s√©curit√© (weak cryptography, SQL injection, etc.)
        #   - Bugs logiques
        # Comment : SpotBugs analyse le bytecode compil√© et g√©n√®re un rapport XML
        #   C'est open-source et gratuit, contrairement √† SonarQube qui n√©cessite un compte cloud
        
      # SonarQube d√©sactiv√© - On utilise SpotBugs pour SAST (suffisant pour le projet)
      # - name: Run SonarQube Scanner (Backend Java) - Optional
      #   if: ${{ secrets.SONAR_TOKEN }}
      #   uses: sonarsource/sonarqube-scan-action@master
      #   env:
      #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      #     SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      #     SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      #   with:
      #     projectBaseDir: ./backend
      #   continue-on-error: true
      # Note : SonarQube est optionnel. SpotBugs est suffisant pour d√©tecter les vuln√©rabilit√©s SAST.
      
      - name: Run ESLint (Frontend JavaScript/React)
        run: |
          cd frontend
          npm ci
          # ESLint avec format JSON pour le parsing (compatible avec flat config)
          npx eslint . --format json --report-unused-disable-directives --max-warnings 0 > eslint-report.json 2>&1 || true
        # Pourquoi : ESLint d√©tecte les probl√®mes dans le code JavaScript/React :
        #   - Erreurs de syntaxe
        #   - Probl√®mes de s√©curit√© (ex: dangerouslySetInnerHTML)
        #   - Mauvaises pratiques
        # Comment : ESLint analyse statiquement le code JS/JSX
        #   --format json g√©n√®re un rapport JSON compatible avec le parser
        #   Note : --ext n'est plus n√©cessaire avec eslint.config.js (flat config)
        
      - name: Save SAST reports
        run: |
          mkdir -p reports/sast
          # Sauvegarder les rapports pour l'√©tape de parsing
          if [ -f frontend/eslint-report.json ]; then
            cp frontend/eslint-report.json reports/sast/eslint-report.json
            echo "‚úÖ ESLint report copi√©"
          else
            echo "‚ö†Ô∏è  ESLint report non trouv√© dans frontend/"
          fi
          
          # V√©rifier que SpotBugs a g√©n√©r√© son rapport
          if [ -f reports/sast/spotbugs-report.xml ]; then
            echo "‚úÖ SpotBugs report trouv√©"
          else
            echo "‚ö†Ô∏è  SpotBugs report non trouv√©"
            # Cr√©er un rapport XML vide pour √©viter les erreurs
            echo '<?xml version="1.0" encoding="UTF-8"?><BugCollection></BugCollection>' > reports/sast/spotbugs-report.xml
          fi
          
          echo "üìã Contenu de reports/sast/:"
          ls -lah reports/sast/
        continue-on-error: true
        # Pourquoi : Centraliser tous les rapports SAST dans un dossier
        # Comment : Cr√©er une structure de dossiers pour organiser les rapports
        
      - name: Upload SAST reports
        uses: actions/upload-artifact@v4
        with:
          name: sast-reports
          path: reports/sast/
          if-no-files-found: warn
        if: always()
        # Pourquoi : Sauvegarder les rapports SAST comme artifacts
        # Comment : Permet de r√©cup√©rer les rapports m√™me si le job √©choue partiellement
        # if-no-files-found: warn affiche un avertissement si aucun fichier n'est trouv√©

  # ============================================
  # JOB 3: SCA - Software Composition Analysis
  # ============================================
  sca:
    name: SCA - Dependency Vulnerability Scan
    runs-on: ubuntu-latest
    needs: build
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'
          
      - name: Prepare SCA reports directory
        run: |
          mkdir -p reports/sca
        # Pourquoi : Cr√©er le dossier AVANT d'ex√©cuter les outils
        # Comment : Les outils ont besoin que le dossier existe pour √©crire les rapports
        
      - name: Run OWASP Dependency-Check (Backend Maven)
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'Backend-Parfumerie'
          path: './backend'
          format: 'JSON'
          args: >
            --enableRetired
            --enableExperimental
            --out .
        # Pourquoi : OWASP Dependency-Check analyse les d√©pendances Maven pour :
        #   - D√©tecter les vuln√©rabilit√©s connues (CVE)
        #   - Identifier les d√©pendances obsol√®tes ou non maintenues
        #   - V√©rifier les licences des d√©pendances
        # Comment : Il compare les versions des d√©pendances avec des bases de donn√©es
        #   de vuln√©rabilit√©s (NVD, etc.) et g√©n√®re un rapport JSON
        # Note : --out . g√©n√®re √† la racine, on le d√©place ensuite
        continue-on-error: true
        
      - name: Find and Rename Dependency-Check report
        run: |
          echo "üîç Recherche du rapport Dependency-Check..."
          # Dependency-Check peut g√©n√©rer le fichier dans diff√©rents emplacements
          # Chercher dans reports/sca/ et √† la racine
          DEPCHECK_FOUND=false
          
          # Chercher dans reports/sca/
          for file in reports/sca/dependency-check-report.json reports/sca/Backend-Parfumerie.json reports/sca/*.json; do
            if [ -f "$file" ] && [ "$file" != "reports/sca/frontend-npm-audit-report.json" ]; then
              echo "‚úÖ Rapport trouv√©: $file"
              mv "$file" reports/sca/backend-dependency-check-report.json
              DEPCHECK_FOUND=true
              break
            fi
          done
          
          # Chercher √† la racine (Dependency-Check peut g√©n√©rer l√†)
          if [ "$DEPCHECK_FOUND" = false ]; then
            for file in dependency-check-report.json Backend-Parfumerie.json; do
              if [ -f "$file" ]; then
                echo "‚úÖ Rapport trouv√© √† la racine: $file"
                mv "$file" reports/sca/backend-dependency-check-report.json
                DEPCHECK_FOUND=true
                break
              fi
            done
          fi
          
          # Si toujours pas trouv√©, chercher r√©cursivement
          if [ "$DEPCHECK_FOUND" = false ]; then
            FOUND_FILE=$(find . -name "dependency-check-report.json" -o -name "Backend-Parfumerie.json" 2>/dev/null | grep -v node_modules | head -1)
            if [ -n "$FOUND_FILE" ]; then
              echo "‚úÖ Rapport trouv√©: $FOUND_FILE"
              cp "$FOUND_FILE" reports/sca/backend-dependency-check-report.json
              DEPCHECK_FOUND=true
            fi
          fi
          
          if [ "$DEPCHECK_FOUND" = false ]; then
            echo "‚ö†Ô∏è  Aucun rapport Dependency-Check trouv√©, cr√©ation d'un rapport vide"
            echo '{"dependencies":[]}' > reports/sca/backend-dependency-check-report.json
          fi
        continue-on-error: true
        # Pourquoi : Trouver et standardiser le nom du fichier Dependency-Check
        # Comment : Cherche dans plusieurs emplacements possibles et renomme
        
      - name: Run npm audit (Frontend npm)
        run: |
          cd frontend
          npm ci
          mkdir -p ../reports/sca
          npm audit --json > ../reports/sca/frontend-npm-audit-report.json 2>&1 || echo '{"vulnerabilities":{}}' > ../reports/sca/frontend-npm-audit-report.json
        continue-on-error: true
        # Pourquoi : npm audit scanne les d√©pendances npm pour :
        #   - Trouver les vuln√©rabilit√©s connues dans les packages
        #   - Identifier les packages obsol√®tes
        # Comment : Utilise la base de donn√©es de s√©curit√© npm
        #   Le format JSON permet de parser les r√©sultats facilement
        #   Si npm audit √©choue, cr√©er un JSON vide pour √©viter les erreurs
        
      - name: Verify SCA reports
        run: |
          echo "üìã V√©rification des rapports SCA..."
          echo "üìÅ Contenu de reports/sca/:"
          ls -lah reports/sca/ || echo "‚ö†Ô∏è  Dossier reports/sca/ vide"
          echo ""
          echo "üìÅ Contenu de la racine (fichiers JSON):"
          ls -lah *.json 2>/dev/null || echo "Aucun JSON √† la racine"
          echo ""
          
          # V√©rifier Dependency-Check
          if [ -f reports/sca/backend-dependency-check-report.json ]; then
            SIZE=$(wc -c < reports/sca/backend-dependency-check-report.json)
            echo "‚úÖ Dependency-Check report trouv√©: $SIZE bytes"
            if [ "$SIZE" -lt 100 ]; then
              echo "‚ö†Ô∏è  Rapport tr√®s petit, peut √™tre vide"
            fi
          else
            echo "‚ùå Dependency-Check report NON trouv√© dans reports/sca/"
            echo '{"dependencies":[]}' > reports/sca/backend-dependency-check-report.json
          fi
          
          # V√©rifier npm audit
          if [ -f reports/sca/frontend-npm-audit-report.json ]; then
            SIZE=$(wc -c < reports/sca/frontend-npm-audit-report.json)
            echo "‚úÖ npm audit report trouv√©: $SIZE bytes"
            if [ "$SIZE" -lt 50 ]; then
              echo "‚ö†Ô∏è  Rapport tr√®s petit, peut √™tre vide"
            fi
          else
            echo "‚ùå npm audit report NON trouv√©"
            echo '{"vulnerabilities":{}}' > reports/sca/frontend-npm-audit-report.json
          fi
          
          # V√©rifier que les fichiers existent avant l'upload
          echo ""
          echo "üìä R√©sum√© avant upload:"
          echo "   - backend-dependency-check-report.json: $([ -f reports/sca/backend-dependency-check-report.json ] && echo '‚úÖ' || echo '‚ùå')"
          echo "   - frontend-npm-audit-report.json: $([ -f reports/sca/frontend-npm-audit-report.json ] && echo '‚úÖ' || echo '‚ùå')"
        continue-on-error: true
        # Pourquoi : V√©rifier que les rapports sont g√©n√©r√©s et cr√©er des rapports vides si n√©cessaire
        # Comment : √âvite les erreurs du parser si les outils √©chouent, affiche des infos de debug
        
      - name: List files before upload
        run: |
          echo "üìã Fichiers dans reports/sca/ avant upload:"
          find reports/sca/ -type f -exec ls -lh {} \;
          echo ""
          echo "üìä V√©rification finale:"
          [ -f reports/sca/backend-dependency-check-report.json ] && echo "‚úÖ backend-dependency-check-report.json existe" || echo "‚ùå backend-dependency-check-report.json MANQUANT"
          [ -f reports/sca/frontend-npm-audit-report.json ] && echo "‚úÖ frontend-npm-audit-report.json existe" || echo "‚ùå frontend-npm-audit-report.json MANQUANT"
        continue-on-error: true
        
      - name: Upload SCA reports
        uses: actions/upload-artifact@v4
        with:
          name: sca-reports
          path: reports/sca/
          if-no-files-found: warn
        if: always()
        # Pourquoi : Sauvegarder les rapports SCA comme artifacts
        # Comment : Permet de r√©cup√©rer les rapports pour l'analyse ult√©rieure
        # if-no-files-found: warn affiche un avertissement si aucun fichier n'est trouv√©

  # ============================================
  # JOB 4: DAST - Dynamic Application Security Testing
  # ============================================
  dast:
    name: DAST - OWASP ZAP Security Scan
    runs-on: ubuntu-latest
    needs: build
    # Pourquoi : DAST n√©cessite que l'application soit d√©marr√©e
    # Comment : On va d√©marrer l'application puis la scanner
    
    # Services disponibles (optionnel - pour services externes si n√©cessaire)
    # services:
    #   postgres:
    #     image: postgres:13
    #     env:
    #       POSTGRES_PASSWORD: postgres
    #     options: >-
    #       --health-cmd pg_isready
    #       --health-interval 10s
    #       --health-timeout 5s
    #       --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'
          
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2
        # Pourquoi : Acc√©l√©rer le build en r√©utilisant les d√©pendances Maven
        
      - name: Build Backend Application
        run: |
          cd backend
          mvn clean install -DskipTests
        # Pourquoi : Compiler l'application avant de la d√©marrer
        # Comment : Maven cr√©e le JAR dans target/
        continue-on-error: true
        
      - name: Start Backend Application
        run: |
          cd backend
          # Trouver le JAR g√©n√©r√©
          JAR_FILE=$(find target -name "*.jar" ! -name "*-sources.jar" ! -name "*-javadoc.jar" | head -1)
          if [ -z "$JAR_FILE" ]; then
            echo "‚ùå Aucun JAR trouv√© dans target/"
            echo "üìã Contenu de target/:"
            ls -lah target/ || echo "Dossier target/ vide"
            exit 1
          fi
          echo "üöÄ D√©marrage de l'application: $JAR_FILE"
          nohup java -jar "$JAR_FILE" > ../app.log 2>&1 &
          APP_PID=$!
          echo $APP_PID > ../app.pid
          echo "üìù PID de l'application: $APP_PID"
          
          # Attendre que l'application d√©marre (v√©rifier le port 8080)
          echo "‚è≥ Attente du d√©marrage de l'application..."
          APP_READY=false
          for i in {1..60}; do
            # V√©rifier si le processus est toujours en cours
            if ! kill -0 $APP_PID 2>/dev/null; then
              echo "‚ùå L'application s'est arr√™t√©e (code de sortie: $?)"
              echo "üìã Logs de l'application:"
              tail -50 ../app.log || echo "Aucun log disponible"
              exit 1
            fi
            
            # V√©rifier si l'application r√©pond
            if curl -f http://localhost:8080/actuator/health 2>/dev/null || curl -f http://localhost:8080 2>/dev/null; then
              echo "‚úÖ Application d√©marr√©e et r√©pond apr√®s ${i}s"
              APP_READY=true
              break
            fi
            sleep 2
          done
          
          if [ "$APP_READY" = false ]; then
            echo "‚ö†Ô∏è  L'application ne r√©pond pas apr√®s 120s"
            echo "üìã Logs de l'application:"
            tail -50 ../app.log || echo "Aucun log disponible"
            echo "üìã Processus Java en cours:"
            ps aux | grep java || echo "Aucun processus Java trouv√©"
            # Ne pas √©chouer, continuer quand m√™me (ZAP peut quand m√™me scanner)
          fi
        # Pourquoi : D√©marrer l'application Spring Boot pour la tester dynamiquement
        # Comment : Lancer l'app en arri√®re-plan, sauvegarder le PID, et v√©rifier qu'elle r√©pond
        continue-on-error: true
        
      - name: Check Docker Availability
        run: |
          echo "üê≥ V√©rification de Docker..."
          if command -v docker &> /dev/null; then
            docker --version
            echo "‚úÖ Docker est disponible"
            # V√©rifier que Docker peut √™tre utilis√©
            docker ps || echo "‚ö†Ô∏è  Docker daemon peut ne pas √™tre d√©marr√©"
          else
            echo "‚ùå Docker n'est pas install√©"
            echo "‚ö†Ô∏è  L'action zaproxy/action-baseline n√©cessite Docker"
          fi
        continue-on-error: true
        # Pourquoi : V√©rifier que Docker est disponible pour ZAP
        # Comment : L'action zaproxy/action-baseline utilise Docker en interne
        
      - name: Verify Application is Running
        run: |
          echo "üîç V√©rification que l'application est accessible..."
          if curl -f http://localhost:8080 2>/dev/null; then
            echo "‚úÖ Application accessible sur http://localhost:8080"
          else
            echo "‚ö†Ô∏è  Application non accessible"
            echo "üìã Tentative de diagnostic..."
            netstat -tuln | grep 8080 || echo "Port 8080 non utilis√©"
            # Cr√©er un rapport vide pour √©viter les erreurs
            mkdir -p reports/dast
            echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
            echo "‚ö†Ô∏è  Rapport vide cr√©√© - l'application n'est pas accessible"
          fi
        continue-on-error: true
        
      - name: Run OWASP ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.10.0
        with:
          target: 'http://localhost:8080'
          cmd_options: '-a -J -t 5'
          report_file: 'zap-report.json'
        # Pourquoi : OWASP ZAP teste l'application EN EX√âCUTION pour :
        #   - D√©tecter les vuln√©rabilit√©s runtime (XSS, SQL injection, etc.)
        #   - Analyser les r√©ponses HTTP
        #   - Tester les endpoints API
        # Comment : ZAP envoie des requ√™tes HTTP malveillantes et analyse les r√©ponses
        #   -a : Active toutes les r√®gles
        #   -J : G√©n√®re un rapport JSON
        #   -t 5 : Timeout de 5 minutes
        #   report_file : Sp√©cifie le nom du fichier de rapport
        continue-on-error: true
        # Note : Si Docker √©choue, on continue et on cr√©e un rapport vide dans Save DAST reports
        
      - name: Stop Backend Application
        if: always()
        run: |
          if [ -f app.pid ]; then
            kill $(cat app.pid) 2>/dev/null || true
            rm -f app.pid
          fi
          pkill -f "java.*jar" || true
        # Pourquoi : Arr√™ter l'application apr√®s le scan
        # Comment : Tuer le processus avec le PID sauvegard√©
        
      - name: Save DAST reports
        run: |
          mkdir -p reports/dast
          # ZAP peut g√©n√©rer le rapport avec diff√©rents noms selon la version
          ZAP_FOUND=false
          for zap_file in zap_report.json report_json.json zap-baseline-report.json zap_report.xml; do
            if [ -f "$zap_file" ]; then
              echo "‚úÖ Rapport ZAP trouv√©: $zap_file"
              # Si c'est XML, on le convertit en JSON minimal (ou on le garde tel quel)
              if [[ "$zap_file" == *.xml ]]; then
                echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
                echo "‚ö†Ô∏è  Rapport XML d√©tect√©, cr√©ation d'un JSON minimal"
              else
                cp "$zap_file" reports/dast/zap-report.json
              fi
              ZAP_FOUND=true
              break
            fi
          done
          
          if [ "$ZAP_FOUND" = false ]; then
            # Cr√©er un rapport vide si aucun rapport n'est trouv√©
            echo '{"@version":"2.11.0","site":[]}' > reports/dast/zap-report.json
            echo "‚ö†Ô∏è  Aucun rapport ZAP trouv√©, cr√©ation d'un rapport vide"
          fi
          
          # V√©rifier que le fichier existe et a du contenu
          if [ -f reports/dast/zap-report.json ]; then
            echo "‚úÖ Rapport DAST sauvegard√©: reports/dast/zap-report.json"
            echo "   Taille: $(wc -c < reports/dast/zap-report.json) bytes"
          fi
        continue-on-error: true
        # Pourquoi : Sauvegarder le rapport ZAP pour l'√©tape de parsing
        # Comment : Chercher le rapport sous diff√©rents noms possibles et cr√©er un rapport vide si n√©cessaire
        
      - name: List files before upload
        run: |
          echo "üìã Fichiers dans reports/dast/ avant upload:"
          find reports/dast/ -type f -exec ls -lh {} \;
          echo ""
          echo "üìä V√©rification finale:"
          [ -f reports/dast/zap-report.json ] && echo "‚úÖ zap-report.json existe" || echo "‚ùå zap-report.json MANQUANT"
        continue-on-error: true
        
      - name: Upload DAST reports
        uses: actions/upload-artifact@v4
        with:
          name: dast-reports
          path: reports/dast/
          if-no-files-found: warn
        if: always()
        # Pourquoi : Sauvegarder les rapports DAST comme artifacts
        # Comment : Permet de r√©cup√©rer les rapports ZAP pour l'analyse
        # if-no-files-found: warn affiche un avertissement si aucun fichier n'est trouv√©

  # ============================================
  # JOB 5: COLLECTE DES RAPPORTS
  # ============================================
  collect-reports:
    name: Collect Security Reports
    runs-on: ubuntu-latest
    needs: [sast, sca, dast]
    # Pourquoi : Collecter tous les rapports apr√®s l'ex√©cution de tous les scans
    # Comment : Ce job attend que SAST, SCA et DAST soient termin√©s
    
    if: always()
    # Pourquoi : Ex√©cuter m√™me si certains jobs √©chouent (pour r√©cup√©rer les rapports)
    # Comment : always() garantit l'ex√©cution ind√©pendamment du r√©sultat
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download SAST artifacts
        uses: actions/download-artifact@v4
        with:
          name: sast-reports
          path: reports/sast
        continue-on-error: true
        # Pourquoi : R√©cup√©rer les rapports SAST des jobs pr√©c√©dents
        # Comment : Les artifacts permettent de partager des fichiers entre jobs
        
      - name: Download SCA artifacts
        uses: actions/download-artifact@v4
        with:
          name: sca-reports
          path: reports/sca
        continue-on-error: true
        
      - name: Download DAST artifacts
        uses: actions/download-artifact@v4
        with:
          name: dast-reports
          path: reports/dast
        continue-on-error: true
        
      - name: Upload all reports
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: reports/
          retention-days: 30
        # Pourquoi : Centraliser tous les rapports de s√©curit√© pour :
        #   - L'analyse et le parsing ult√©rieur
        #   - L'audit et la conformit√©
        #   - La g√©n√©ration de politiques avec LLM
        # Comment : Les artifacts sont disponibles en t√©l√©chargement depuis GitHub
        #   retention-days garde les rapports 30 jours

